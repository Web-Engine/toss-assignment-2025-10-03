[Interface]
Address = 10.0.0.1/24
ListenPort = 51820
Table = off
PrivateKey = +Ne3SIhtCwJIJl9qt8lTCmTRyN7ipu+ZoYTy2RfGz0c=

PostUp = modprobe nf_tproxy_ipv4 2>/dev/null || true
PostUp = modprobe nf_tproxy_ipv6 2>/dev/null || true
PostUp = modprobe xt_TPROXY 2>/dev/null || true
PostUp = modprobe nft_tproxy 2>/dev/null || true
PostUp = modprobe nfnetlink_queue 2>/dev/null || true

# 정책 라우팅: fwmark 1 -> table 100
PostUp = ip rule add fwmark 1 lookup 100 2>/dev/null || true
PostUp = ip route add local 0.0.0.0/0 dev lo table 100 2>/dev/null || true

# 아래 로직 정리해서 다음과 같이 수정 필요
# - 1. conntrack mark -> skb meta mark:
# - 2. skb mark == 0 (unmarked, 판단되지 않음) -> nfqueue
# - 3. skb mark == 1 (handle mark) -> tproxy
# - 4. skb mark == 2 (bypass) -> bypass rule

# syn packet은 bypass 필요

# nfqueue handler에서 판단 전까지는 ACCEPT하면 안됨
# nfqueue 에서는 간단한 HTTP/HTTPS 인식 및 SNI 검사
# tproxy app에서는 HTTP/HTTPS 프록시 및 MITM 동작
# -----------------------------
# WireGuard PostUp / PostDown
# -----------------------------

# ========== PostUp ==========

PostUp = sudo sysctl -w net.ipv4.ip_forward=1

# 0) 정책 라우팅( TPROXY용 ): fwmark=1 → table 100 → local lo
PostUp = ip rule add fwmark 1 lookup 100 2>/dev/null || true
PostUp = ip route add local 0.0.0.0/0 dev lo table 100 2>/dev/null || true

# (선택) rp_filter 완화: 역방향 경로검사로 인한 드롭 방지
PostUp = sysctl -w net.ipv4.conf.all.rp_filter=0 > /dev/null
PostUp = sysctl -w net.ipv4.conf.%i.rp_filter=0 > /dev/null

# 1) nft: table/chain 생성 (idempotent)
PostUp = nft add table ip mangle 2>/dev/null || true
PostUp = nft 'add chain ip mangle prerouting { type filter hook prerouting priority -150; }' 2>/dev/null || true

# (선택) WireGuard 오버헤드 대비 MSS clamp
# PostUp = nft list chain ip mangle prerouting 2>/dev/null | grep -Fq "wg-mss-clamp-%i" || nft add rule ip mangle prerouting tcp flags syn tcp option maxseg size set rt mtu comment "wg-mss-clamp-%i"
# PostUp = nft list chain ip mangle prerouting 2>/dev/null | grep -Fq "wg-mss-clamp-%i" || nft add rule ip mangle prerouting tcp flags syn tcp option maxseg size set clamp to pmtu comment "wg-mss-clamp-%i"

# 2) conntrack mark -> skb meta mark 복원 (가장 앞)
PostUp = nft list chain ip mangle prerouting 2>/dev/null | grep -Fq 'wg-restore-mark' || nft add rule ip mangle prerouting ct mark != 0 meta mark set ct mark comment "wg-restore-mark"

# 3) 핸드셰이크 지연 방지: SYN은 큐잉하지 않음
PostUp = nft list chain ip mangle prerouting 2>/dev/null | grep -Fq "wg-bypass-syn-%i" || nft add rule ip mangle prerouting iifname "%i" tcp flags syn accept comment "wg-bypass-syn-%i"

# 4) NFQUEUE: 미결정(meta mark==0)만 큐로 보냄
PostUp = nft list chain ip mangle prerouting 2>/dev/null | grep -Fq "wg-nfq-%i" || nft add rule ip mangle prerouting iifname "%i" meta l4proto tcp meta mark 0 queue num 1-4 fanout comment "wg-nfq-%i"

# 5) TPROXY: proxy 결정(meta mark==1)만 로컬 프록시로 전달
PostUp = nft list chain ip mangle prerouting 2>/dev/null | grep -Fq "wg-tproxy-%i" || nft add rule ip mangle prerouting iifname "%i" meta l4proto tcp meta mark 1 tproxy to :3129 comment "wg-tproxy-%i"

# 6) BYPASS: bypass 결정(meta mark==2)은 커널 라우팅 그대로 통과
PostUp = nft list chain ip mangle prerouting 2>/dev/null | grep -Fq "wg-bypass-%i" || nft add rule ip mangle prerouting iifname "%i" meta l4proto tcp meta mark 2 accept comment "wg-bypass-%i"

PostUp = nft add table ip nat
PostUp = nft 'add chain ip nat postrouting { type nat hook postrouting priority 100; }'
PostUp = nft list chain ip nat postrouting 2>/dev/null | grep -Fq "wg-masquerade-%i" || nft add rule ip nat postrouting oifname "ens5" ip saddr 10.0.0.0/24 masquerade comment "wg-masquerade-%i"


# ========== PostDown ==========

# nat/postrouting에 심어둔 룰을 comment로 찾아 제거
PostDown = nft -a list chain ip nat postrouting 2>/dev/null | awk -v t="wg-masquerade-%i"        '$0 ~ "rule" && $0 ~ t {for(i=1;i<=NF;i++) if ($i=="handle") print $(i+1)}' | while read h; do nft delete rule ip nat postrouting handle "$h" 2>/dev/null || true; done

# mangle/prerouting에 심어둔 룰을 comment로 찾아 제거
PostDown = nft -a list chain ip mangle prerouting 2>/dev/null | awk -v t="wg-bypass-%i"        '$0 ~ "rule" && $0 ~ t {for(i=1;i<=NF;i++) if ($i=="handle") print $(i+1)}' | while read h; do nft delete rule ip mangle prerouting handle "$h" 2>/dev/null || true; done
PostDown = nft -a list chain ip mangle prerouting 2>/dev/null | awk -v t="wg-tproxy-%i"        '$0 ~ "rule" && $0 ~ t {for(i=1;i<=NF;i++) if ($i=="handle") print $(i+1)}' | while read h; do nft delete rule ip mangle prerouting handle "$h" 2>/dev/null || true; done
PostDown = nft -a list chain ip mangle prerouting 2>/dev/null | awk -v t="wg-nfq-%i"           '$0 ~ "rule" && $0 ~ t {for(i=1;i<=NF;i++) if ($i=="handle") print $(i+1)}' | while read h; do nft delete rule ip mangle prerouting handle "$h" 2>/dev/null || true; done
PostDown = nft -a list chain ip mangle prerouting 2>/dev/null | awk -v t="wg-bypass-syn-%i"    '$0 ~ "rule" && $0 ~ t {for(i=1;i<=NF;i++) if ($i=="handle") print $(i+1)}' | while read h; do nft delete rule ip mangle prerouting handle "$h" 2>/dev/null || true; done
PostDown = nft -a list chain ip mangle prerouting 2>/dev/null | awk -v t="wg-restore-mark"     '$0 ~ "rule" && $0 ~ t {for(i=1;i<=NF;i++) if ($i=="handle") print $(i+1)}' | while read h; do nft delete rule ip mangle prerouting handle "$h" 2>/dev/null || true; done
PostDown = nft -a list chain ip mangle prerouting 2>/dev/null | awk -v t="wg-mss-clamp-%i"     '$0 ~ "rule" && $0 ~ t {for(i=1;i<=NF;i++) if ($i=="handle") print $(i+1)}' | while read h; do nft delete rule ip mangle prerouting handle "$h" 2>/dev/null || true; done

# 정책 라우팅 제거
PostDown = ip route show table 100 | grep -q "local 0.0.0.0/0 dev lo" && ip route del local 0.0.0.0/0 dev lo table 100 2>/dev/null || true
PostDown = ip rule show | grep -q "fwmark 0x1 lookup 100" && ip rule del fwmark 1 lookup 100 2>/dev/null || true

PostDown = sudo sysctl -w net.ipv4.ip_forward=0

[Peer]
PublicKey = DIg/M9qTGNLJ4QXVER4cjDCMQ9y1WLQ7XGGifDdhHms=
AllowedIPs = 10.0.0.2/32